/**
 * executionservice.hpp
 * Defines the data types and Service for executions.
 *
 * @author Breman Thuraisingham
 */

// Modified by Zichao Wang
// Date: Dec 21, 2018

#ifndef EXECUTION_SERVICE_HPP
#define EXECUTION_SERVICE_HPP

#include <string>
#include "Foundation/soa.hpp"
#include "Foundation/products.hpp"
#include "RightPath/RightPathGeneral/marketdataservice.hpp"

enum OrderType { FOK, IOC, MARKET, LIMIT, STOP };

enum Market { BROKERTEC, ESPEED, CME };

/**
 * An execution order that can be placed on an exchange.
 * Type T is the product type.
 */
template<typename T>
class ExecutionOrder
{
private:
    T product;
    PricingSide side;
    string orderId;
    OrderType orderType;
    double price;
    long visibleQuantity;
    long hiddenQuantity;
    string parentOrderId;
    bool isChildOrder;

public:
    // ctor for an order
    ExecutionOrder() = default;

    ExecutionOrder(const T &_product, PricingSide _side, string _orderId, OrderType _orderType, double _price, long _visibleQuantity, long _hiddenQuantity, string _parentOrderId, bool _isChildOrder) : product(_product)
    {
        side = _side;
        orderId = _orderId;
        orderType = _orderType;
        price = _price;
        visibleQuantity = _visibleQuantity;
        hiddenQuantity = _hiddenQuantity;
        parentOrderId = _parentOrderId;
        isChildOrder = _isChildOrder;
    }

    // Overload assignment operator.
    ExecutionOrder<T>& operator =(const ExecutionOrder& _executionOrder)
    {
        product = _executionOrder.GetProduct();
        side = _executionOrder.GetPricingSide();
        orderId = _executionOrder.GetOrderId();
        orderType = _executionOrder.GetOrderType();
        price = _executionOrder.GetPrice();
        visibleQuantity = _executionOrder.GetVisibleQuantity();
        hiddenQuantity = _executionOrder.GetHiddenQuantity();
        parentOrderId = _executionOrder.GetParentOrderId();
        isChildOrder = _executionOrder.IsChildOrder();
        return *this;
    }

    // Get the product
    const T& GetProduct() const
    {
        return product;
    }

    // Get pricing side
    PricingSide GetPricingSide() const
    {
        return side;
    }

    // Get the order ID
    const string& GetOrderId() const
    {
        return orderId;
    }

    // Get the order type on this order
    OrderType GetOrderType() const
    {
        return orderType;
    }

    // Get the price on this order
    double GetPrice() const
    {
        return price;
    }

    // Get the visible quantity on this order
    long GetVisibleQuantity() const
    {
        return visibleQuantity;
    }

    // Get the hidden quantity
    long GetHiddenQuantity() const
    {
        return hiddenQuantity;
    }

    // Get the parent order ID
    const string& GetParentOrderId() const
    {
        return parentOrderId;
    }

    // Is child order?
    bool IsChildOrder() const
    {
        return isChildOrder;
    }

    // Print execution order info.
    void Print();

};

template<typename T>
void ExecutionOrder<T>::Print()
{
    string type;
    switch(orderType)
    {
        case FOK: type = "FOK"; break;
        case MARKET: type = "MARKET"; break;
        case LIMIT: type = "LIMIT"; break;
        case STOP: type = "STOP"; break;
        case IOC: type = "IOC"; break;
        default: type = "OTHER";
    }

    cout << "Product: ";
    GetProduct().Print();
    cout << endl;
    cout << "  pricing side: " << (side == BID ? "BID" : "OFFER")<< endl;
    cout << "  order ID: " << orderId << endl;
    cout << "  order type: " << type << endl;
    cout << "  price: " << price << endl;
    cout << "  visible quantity: " << visibleQuantity << endl;
    cout << "  hidden quantity: " << hiddenQuantity << endl;
    cout << "  parent order ID: " << parentOrderId << endl;
    cout << "  is child order: " << std::boolalpha << isChildOrder << endl;
}


static int id = 0;
// Use some algo to generate execution order
// according to a given order book.
class AlgoExecution
{
private:
    // AlgoExecution class bears an execution order which
    // will be generated by AlgoExecution class using some algo.
    ExecutionOrder<Bond> executionOrder;

public:
    // ctor
    AlgoExecution() = default;
    AlgoExecution(const OrderBook<Bond>& orderBook)
    {
        Bond bond = orderBook.GetProduct();

        // We mimic some strategy in the following.
        //int id = 0;
        id++;
        std::string orderID = "O" + std::to_string(id);
        PricingSide pricingSide = ((id % 2) ? BID : OFFER);
        OrderType orderType;
        switch(id % 5)
        {
            case 0: orderType = FOK; break;
            case 1: orderType = MARKET; break;
            case 2: orderType = LIMIT; break;
            case 3: orderType = STOP; break;
            default: orderType = IOC;
        }

        auto offerIter = orderBook.GetOfferStack().begin();
        auto bidIter = orderBook.GetBidStack().begin();

        // Note that we have to cross the spread.
        double price = ((pricingSide == BID) ? offerIter->GetPrice() : bidIter->GetPrice());
        long visibleQuantity = ((pricingSide == BID) ? offerIter->GetQuantity() : bidIter->GetQuantity());
        long hiddenQuantity = 0;
        std::string parentID = orderID + "P";
        bool isChild = true;

        ExecutionOrder<Bond> tempExecutionOrder(bond, pricingSide, orderID, orderType, price, visibleQuantity, hiddenQuantity, parentID, isChild);

        executionOrder = tempExecutionOrder;
    }

    // copy ctor
    AlgoExecution(const AlgoExecution& _algoExecution)
    {
        executionOrder = _algoExecution.GetExecutionOrder();
    }

    // Get internal execution order.
    ExecutionOrder<Bond> GetExecutionOrder() const
    {
        return executionOrder;
    }

    // Update execution order given new order book.
    void UpdateOrderBook(const OrderBook<Bond> & newOrderBook);

};


void AlgoExecution::UpdateOrderBook(const OrderBook<Bond> &newOrderBook)
{
    // First check if this new order book and our internal
    // execution order has the same CUSIP.
    if(newOrderBook.GetProduct().GetProductId() != executionOrder.GetProduct().GetProductId())
        return;

    // Use some strategy to update internal execution order.
    //static int id = 0;
    id++;
    std::string orderID = "O" + std::to_string(id);
    PricingSide pricingSide = ((id % 2) ? BID : OFFER);
    OrderType orderType;
    switch(id % 5)
    {
        case 0: orderType = FOK; break;
        case 1: orderType = MARKET; break;
        case 2: orderType = LIMIT; break;
        case 3: orderType = STOP; break;
        default: orderType = IOC;
    }

    auto offerIter = newOrderBook.GetOfferStack().begin();
    auto bidIter = newOrderBook.GetBidStack().begin();
    double price = ((pricingSide == BID) ? offerIter->GetPrice() : bidIter->GetPrice());
    long visibleQuantity = ((pricingSide == BID) ? offerIter->GetQuantity() : bidIter->GetQuantity());
    long hiddenQuantity = 0;
    std::string parentID = orderID + "P";
    bool isChild = true;
    ExecutionOrder<Bond> tempExecutionOrder(executionOrder.GetProduct(), pricingSide, orderID, orderType, price, visibleQuantity, hiddenQuantity, parentID, isChild);

    executionOrder = tempExecutionOrder;
}


/**
 * Service for executing orders on an exchange.
 * Keyed on product identifier.
 * Type T is the product type.
 */
template<typename T>
class ExecutionService : public Service<string, ExecutionOrder<T> >
{
public:
    // Execute an order on a market
    virtual void ExecuteOrder(const ExecutionOrder<T>& order, Market market) = 0;

};


#endif
